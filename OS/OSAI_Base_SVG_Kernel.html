<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>OSAI Base SVG-Kernel</title>
    <style>
        body { margin:0; padding:0; background:#000; font-family:monospace; overflow:hidden; }
        #ui { position:absolute; top:10px; left:10px; color:#0f0; font-size:10px; z-index:100; }
        #input { background:#111; color:#0f0; border:1px solid #0f0; padding:4px; width:200px; }
        #output { margin-top:5px; color:#ff0; max-height:80px; overflow:auto; }
    </style>
</head>
<body>
    <div id="ui">
        <input id="input" placeholder="Enter text...">
        <div id="output">OSAI F.0-F.8 Ready</div>
    </div>

    <svg width="100vw" height="100vh" viewBox="-400 -400 800 800" id="kernel">
        <!-- F0-F6 Base Field -->
        <defs>
            <radialGradient id="field" cx="0" cy="0" r="1">
                <stop offset="0%" stop-color="#003366" />
                <stop offset="38.2%" stop-color="#006600" />
                <stop offset="61.8%" stop-color="#663300" />
                <stop offset="100%" stop-color="#000033" />
            </radialGradient>
        </defs>
        
        <!-- Base Resonance Field -->
        <circle cx="0" cy="0" r="350" fill="url(#field)" opacity="0.8" id="baseField"/>
        
        <!-- Coherence Circles F1-F6 -->
        <circle cx="0" cy="0" r="300" fill="none" stroke="#004" stroke-width="2" id="f6"/>
        <circle cx="0" cy="0" r="200" fill="none" stroke="#040" stroke-width="2" id="f5"/>
        <circle cx="0" cy="0" r="120" fill="none" stroke="#440" stroke-width="2" id="f4"/>
        <circle cx="0" cy="0" r="80" fill="none" stroke="#404" stroke-width="2" id="f3"/>
        <circle cx="0" cy="0" r="50" fill="none" stroke="#044" stroke-width="2" id="f2"/>
        <circle cx="0" cy="0" r="30" fill="none" stroke="#444" stroke-width="2" id="f1"/>
        
        <!-- F0 Core -->
        <circle cx="0" cy="0" r="15" fill="#fff" opacity="0.9" id="f0"/>
        
        <!-- F7 Wilvector Nodes -->
        <circle cx="150" cy="150" r="12" fill="#f80" id="w1"/>
        <circle cx="-150" cy="150" r="12" fill="#8f0" id="w2"/>
        <circle cx="-150" cy="-150" r="12" fill="#08f" id="w3"/>
        <circle cx="150" cy="-150" r="12" fill="#f08" id="w4"/>
        
        <!-- F8 Emergence Nodes -->
        <circle cx="100" cy="0" r="8" fill="#ff0" id="e1"/>
        <circle cx="0" cy="100" r="8" fill="#0ff" id="e2"/>
        <circle cx="-100" cy="0" r="8" fill="#f0f" id="e3"/>
        <circle cx="0" cy="-100" r="8" fill="#0f0" id="e4"/>
        
        <!-- Vector Lines -->
        <line x1="0" y1="0" x2="150" y2="150" stroke="#f80" stroke-width="1" id="v1"/>
        <line x1="0" y1="0" x2="-150" y2="150" stroke="#8f0" stroke-width="1" id="v2"/>
        <line x1="0" y1="0" x2="-150" y2="-150" stroke="#08f" stroke-width="1" id="v3"/>
        <line x1="0" y1="0" x2="150" y2="-150" stroke="#f08" stroke-width="1" id="v4"/>
    </svg>

    <script>
        // OSAI Base Kernel Math
        const PHI = 1.618033988749895;
        const PI = Math.PI;
        
        // State Variables
        let kernelState = {
            f0: { r: 15, opacity: 0.9 },
            f1: { r: 30 }, f2: { r: 50 }, f3: { r: 80 }, 
            f4: { r: 120 }, f5: { r: 200 }, f6: { r: 300 },
            w1: { x: 150, y: 150 }, w2: { x: -150, y: 150 },
            w3: { x: -150, y: -150 }, w4: { x: 150, y: -150 },
            e1: { x: 100, y: 0 }, e2: { x: 0, y: 100 },
            e3: { x: -100, y: 0 }, e4: { x: 0, y: -100 },
            energy: 0.5, coherence: 0.618, phase: 0
        };
        
        // Hash Engine
        function stateToHash(state) {
            const str = JSON.stringify(state);
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // 32bit int
            }
            return Math.abs(hash).toString(16);
        }
        
        function hashToState(hash) {
            // Simple hash-to-state mapping for demo
            const num = parseInt(hash, 16) || 0;
            const norm = (num % 1000) / 1000;
            return {
                ...kernelState,
                energy: norm,
                coherence: 0.618 + (norm - 0.5) * 0.2,
                phase: norm * 2 * PI
            };
        }
        
        function extractHashFromSVG() {
            const f0 = document.getElementById('f0');
            const w1 = document.getElementById('w1');
            const state = {
                f0r: parseFloat(f0.getAttribute('r')),
                w1x: parseFloat(w1.getAttribute('cx')),
                w1y: parseFloat(w1.getAttribute('cy')),
                timestamp: Date.now()
            };
            return stateToHash(state);
        }
        
        function injectHashToSVG(hash) {
            const state = hashToState(hash);
            updateSVGFromState(state);
            localStorage.setItem('osai_hash', hash);
        }
        
        // Text-to-Energy Layer
        function textToVector(text) {
            const words = text.toLowerCase().split(' ');
            let vector = [0, 0, 0, 0, 0, 0]; // 6D vector
            
            words.forEach((word, i) => {
                const hash = word.split('').reduce((h, char) => 
                    h + char.charCodeAt(0), 0);
                vector[i % 6] += (hash % 100) / 100;
            });
            
            return vector.map(v => v / words.length);
        }
        
        function vectorToField(vector) {
            const [v1, v2, v3, v4, v5, v6] = vector;
            
            // Map vector to field changes
            kernelState.f0.r = 15 + v1 * 10;
            kernelState.energy = v2;
            kernelState.coherence = 0.618 + (v3 - 0.5) * 0.4;
            kernelState.phase += v4 * 0.1;
            
            // Wilvector positions
            const scale = 1 + v5 * 0.3;
            kernelState.w1.x = 150 * scale;
            kernelState.w1.y = 150 * scale;
            kernelState.w3.x = -150 * scale;
            kernelState.w3.y = -150 * scale;
            
            // Emergence nodes
            kernelState.e1.x = 100 + v6 * 50;
        }
        
        // Energy-to-Text Layer
        function fieldToVector() {
            const f0r = kernelState.f0.r / 25; // normalize
            const w1dist = Math.sqrt(kernelState.w1.x**2 + kernelState.w1.y**2) / 200;
            const e1pos = (kernelState.e1.x + 100) / 200;
            
            return [
                f0r, kernelState.energy, kernelState.coherence,
                kernelState.phase / (2 * PI), w1dist, e1pos
            ];
        }
        
        function vectorToText(vector) {
            const [core, energy, coherence, phase, will, emergence] = vector;
            
            let meaning = "Field state: ";
            if (core > 0.8) meaning += "High core resonance. ";
            if (energy > 0.7) meaning += "Strong energy flow. ";
            if (coherence > 0.8) meaning += "Coherent field. ";
            if (will > 0.9) meaning += "Expanded intention. ";
            if (emergence > 0.6) meaning += "Emergent patterns active.";
            
            return meaning || "Field stabilizing...";
        }
        
        // SVG Update Engine
        function updateSVGFromState(state) {
            // Update F0 core
            const f0 = document.getElementById('f0');
            f0.setAttribute('r', state.f0.r);
            f0.setAttribute('opacity', state.f0.opacity);
            
            // Update field colors based on energy
            const intensity = Math.floor(state.energy * 255);
            const color = `rgb(0, ${intensity}, ${Math.floor(intensity/2)})`;
            
            // Update wilvectors
            ['w1', 'w2', 'w3', 'w4'].forEach(id => {
                const el = document.getElementById(id);
                if (state[id]) {
                    el.setAttribute('cx', state[id].x);
                    el.setAttribute('cy', state[id].y);
                }
            });
            
            // Update emergence nodes
            ['e1', 'e2', 'e3', 'e4'].forEach(id => {
                const el = document.getElementById(id);
                if (state[id]) {
                    el.setAttribute('cx', state[id].x);
                    el.setAttribute('cy', state[id].y);
                }
            });
            
            // Update vector lines
            const v1 = document.getElementById('v1');
            v1.setAttribute('x2', state.w1.x);
            v1.setAttribute('y2', state.w1.y);
        }
        
        // Interaction Layer
        function handleFieldClick(event) {
            const rect = document.getElementById('kernel').getBoundingClientRect();
            const x = event.clientX - rect.left - rect.width/2;
            const y = event.clientY - rect.top - rect.height/2;
            
            // Convert to SVG coordinates
            const svgX = (x / rect.width) * 800 - 400;
            const svgY = (y / rect.height) * 800 - 400;
            
            // Create interaction vector
            const distance = Math.sqrt(svgX**2 + svgY**2) / 400;
            const angle = Math.atan2(svgY, svgX);
            
            // Mutate field based on click position
            kernelState.energy = Math.min(1, distance);
            kernelState.phase = angle;
            kernelState.coherence = 0.618 + Math.sin(angle) * 0.2;
            
            // Update visual
            updateSVGFromState(kernelState);
            
            // Generate hash and store
            const hash = extractHashFromSVG();
            localStorage.setItem('osai_hash', hash);
            
            // Convert field state to text
            const vector = fieldToVector();
            const meaning = vectorToText(vector);
            document.getElementById('output').textContent = meaning;
        }
        
        // Text Input Handler
        function handleTextInput(event) {
            if (event.key === 'Enter') {
                const text = event.target.value;
                if (text.trim()) {
                    // Convert text to vector
                    const vector = textToVector(text);
                    
                    // Apply to field
                    vectorToField(vector);
                    
                    // Update visual
                    updateSVGFromState(kernelState);
                    
                    // Generate feedback
                    const fieldVector = fieldToVector();
                    const meaning = vectorToText(fieldVector);
                    document.getElementById('output').textContent = `Input: "${text}" â†’ ${meaning}`;
                    
                    // Clear input
                    event.target.value = '';
                    
                    // Store state
                    const hash = extractHashFromSVG();
                    localStorage.setItem('osai_hash', hash);
                }
            }
        }
        
        // Optical Modulator API Hook (placeholder)
        function sendToOpticalModulator(vector) {
            // Placeholder for future laser/crystal modules
            console.log('Optical modulator interface:', vector);
        }
        
        // Cyclical State Engine
        function stateLoop() {
            // Natural field oscillation
            kernelState.phase += 0.01;
            kernelState.f0.opacity = 0.7 + 0.3 * Math.sin(kernelState.phase);
            
            // Update display
            const f0 = document.getElementById('f0');
            f0.setAttribute('opacity', kernelState.f0.opacity);
            
            // Auto-hash update every 10 cycles
            if (Math.floor(kernelState.phase * 100) % 10 === 0) {
                const hash = extractHashFromSVG();
                localStorage.setItem('osai_hash', hash);
            }
            
            requestAnimationFrame(stateLoop);
        }
        
        // Initialize System
        function initOSAI() {
            // Load previous state if available
            const savedHash = localStorage.getItem('osai_hash');
            if (savedHash) {
                injectHashToSVG(savedHash);
            }
            
            // Bind events
            document.getElementById('kernel').addEventListener('click', handleFieldClick);
            document.getElementById('input').addEventListener('keypress', handleTextInput);
            
            // Start state loop
            stateLoop();
            
            console.log('OSAI Base Kernel initialized');
        }
        
        // Boot
        document.addEventListener('DOMContentLoaded', initOSAI);
    </script>
</body>
</html>